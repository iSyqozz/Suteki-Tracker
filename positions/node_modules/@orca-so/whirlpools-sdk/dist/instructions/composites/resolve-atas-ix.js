var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { resolveOrCreateATAs, TokenUtil } from "@orca-so/common-sdk";
import { PublicKey } from "@solana/web3.js";
import { convertListToMap } from "../../utils/txn-utils";
/**
 * Build instructions to resolve ATAs (Associated Tokens Addresses) for affliated tokens in a list of Whirlpools.
 * Affliated tokens are tokens that are part of the trade pair or reward in a Whirlpool.
 *
 * SOL tokens does not use the ATA program and therefore not handled.
 *
 * @param ctx - WhirlpoolContext object for the current environment.

 * @returns a ResolvedTokenAddressesIxSet containing the derived ATA addresses & ix set to initialize the accounts.
 */
export function resolveAtaForWhirlpoolsIxs(ctx, params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { whirlpools, receiver, payer, accountExemption } = params;
        const receiverKey = receiver !== null && receiver !== void 0 ? receiver : ctx.wallet.publicKey;
        const payerKey = payer !== null && payer !== void 0 ? payer : ctx.wallet.publicKey;
        const affliatedTokens = getAffliatedTokenMints(whirlpools);
        const resolvedAtaResults = yield resolveOrCreateATAs(ctx.connection, receiverKey, affliatedTokens.map((tokenMint) => {
            return { tokenMint };
        }), () => __awaiter(this, void 0, void 0, function* () { return accountExemption; }), payerKey);
        // Convert the results back into the specified format 
        const { resolveAtaIxs, resolvedAtas } = resolvedAtaResults.reduce((accu, curr) => {
            const { address } = curr, ix = __rest(curr, ["address"]);
            accu.resolvedAtas.push(address);
            // TODO: common-sdk needs to have an easier way to check for empty instruction
            if (ix.instructions.length) {
                accu.resolveAtaIxs.push(ix);
            }
            return accu;
        }, { resolvedAtas: [], resolveAtaIxs: [] });
        const affliatedTokenAtaMap = convertListToMap(resolvedAtas, affliatedTokens.map((mint) => mint.toBase58()));
        return {
            ataTokenAddresses: affliatedTokenAtaMap,
            resolveAtaIxs,
        };
    });
}
function getAffliatedTokenMints(whirlpoolDatas) {
    return Array.from(whirlpoolDatas.reduce((accu, whirlpoolData) => {
        if (whirlpoolData) {
            const { tokenMintA, tokenMintB } = whirlpoolData;
            if (!TokenUtil.isNativeMint(tokenMintA)) {
                accu.add(tokenMintA);
            }
            if (!TokenUtil.isNativeMint(tokenMintB)) {
                accu.add(tokenMintB);
            }
            const rewardInfos = whirlpoolData.rewardInfos;
            rewardInfos.forEach((reward) => {
                if (!reward.mint.equals(PublicKey.default)) {
                    accu.add(reward.mint);
                }
            });
        }
        return accu;
    }, new Set()));
}
