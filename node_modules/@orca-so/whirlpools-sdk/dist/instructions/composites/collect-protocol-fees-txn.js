"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectProtocolFees = void 0;
const common_sdk_1 = require("@orca-so/common-sdk");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const __1 = require("..");
const whirlpool_ata_utils_1 = require("../../utils/whirlpool-ata-utils");
function collectProtocolFees(ctx, poolAddresses) {
    return __awaiter(this, void 0, void 0, function* () {
        const receiverKey = ctx.wallet.publicKey;
        const payerKey = ctx.wallet.publicKey;
        const whirlpoolDatas = yield ctx.fetcher.listPools(poolAddresses, false);
        const accountExemption = yield ctx.fetcher.getAccountRentExempt();
        const { ataTokenAddresses, resolveAtaIxs } = yield (0, whirlpool_ata_utils_1.resolveAtaForMints)(ctx, {
            mints: (0, whirlpool_ata_utils_1.getTokenMintsFromWhirlpools)(whirlpoolDatas, whirlpool_ata_utils_1.TokenMintTypes.POOL_ONLY).mintMap,
            accountExemption,
            receiver: receiverKey,
            payer: payerKey,
        });
        const latestBlockhash = yield ctx.connection.getLatestBlockhash("singleGossip");
        let txBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet).addInstructions(resolveAtaIxs);
        const instructions = [];
        for (const poolAddress of poolAddresses) {
            const pool = yield ctx.fetcher.getPool(poolAddress);
            if (!pool) {
                throw new Error(`Pool not found: ${poolAddress}`);
            }
            const poolConfig = yield ctx.fetcher.getConfig(pool.whirlpoolsConfig);
            if (!poolConfig) {
                throw new Error(`Config not found: ${pool.whirlpoolsConfig}`);
            }
            if (poolConfig.collectProtocolFeesAuthority.toBase58() !== ctx.wallet.publicKey.toBase58()) {
                throw new Error(`Wallet is not the collectProtocolFeesAuthority`);
            }
            const poolHandlesNativeMint = common_sdk_1.TokenUtil.isNativeMint(pool.tokenMintA) || common_sdk_1.TokenUtil.isNativeMint(pool.tokenMintB);
            const txBuilderHasNativeMint = !!ataTokenAddresses[spl_token_1.NATIVE_MINT.toBase58()];
            if (poolHandlesNativeMint && !txBuilderHasNativeMint) {
                (0, whirlpool_ata_utils_1.addNativeMintHandlingIx)(txBuilder, ataTokenAddresses, receiverKey, accountExemption);
            }
            // add collect ixn
            instructions.push((0, __1.collectProtocolFeesIx)(ctx.program, {
                whirlpoolsConfig: pool.whirlpoolsConfig,
                whirlpool: common_sdk_1.AddressUtil.toPubKey(poolAddress),
                tokenVaultA: pool.tokenVaultA,
                tokenVaultB: pool.tokenVaultB,
                tokenOwnerAccountA: ataTokenAddresses[pool.tokenMintA.toBase58()],
                tokenOwnerAccountB: ataTokenAddresses[pool.tokenMintB.toBase58()],
                collectProtocolFeesAuthority: poolConfig.collectProtocolFeesAuthority,
            }));
        }
        txBuilder.addInstructions(instructions);
        const txSize = yield txBuilder.txnSize({ latestBlockhash });
        if (txSize > web3_js_1.PACKET_DATA_SIZE) {
            throw new Error(`Transaction size is too large: ${txSize}`);
        }
        return txBuilder;
    });
}
exports.collectProtocolFees = collectProtocolFees;
