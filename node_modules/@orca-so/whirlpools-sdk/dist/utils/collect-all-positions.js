"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNativeMint = exports.collectForAllPositions = exports.collectForAllPositionAddrs = void 0;
const common_sdk_1 = require("@orca-so/common-sdk");
const token_instructions_1 = require("@orca-so/common-sdk/dist/helpers/token-instructions");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const position_impl_1 = require("../impl/position-impl");
const instructions_1 = require("../instructions");
const ix_1 = require("../ix");
const public_1 = require("./public");
const spl_token_utils_1 = require("./spl-token-utils");
function collectForAllPositionAddrs(ctx, positionAddrs, refresh = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const posDatas = yield ctx.fetcher.listPositions(positionAddrs, refresh);
        console.log(`collectForAllPositionAddrs handle ${posDatas.length} positions`);
        const positions = posDatas.reduce((accu, curr, index) => {
            if (curr) {
                accu.push(new position_impl_1.PositionImpl(ctx, common_sdk_1.AddressUtil.toPubKey(positionAddrs[index]), curr));
            }
            return accu;
        }, []);
        return collectForAllPositions(ctx, positions);
    });
}
exports.collectForAllPositionAddrs = collectForAllPositionAddrs;
function collectForAllPositions(ctx, positions, destinationWallet = ctx.wallet.publicKey, positionOwner = ctx.wallet.publicKey, positionAuthority = ctx.wallet.publicKey, payer = ctx.wallet.publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(`collectForAllPositions handle ${positions.length} positions`);
        const whirlpoolAddrs = positions.map((pos) => pos.getData().whirlpool.toBase58());
        const whirlpoolDatas = yield ctx.fetcher.listPools(whirlpoolAddrs, false);
        const whirlpools = convertListToMap(whirlpoolDatas, whirlpoolAddrs);
        // TODO: Payer is not configurable here. Forced to use wallet
        const { affliatedTokenAtaMap, resolveAtaIxs } = yield resolveAtaForWhirlpools(ctx, whirlpoolDatas, destinationWallet, payer);
        console.log(`resolveAtaIxs - ${resolveAtaIxs.length}`);
        const accountExemption = yield ctx.fetcher.getAccountRentExempt();
        const txBuilders = [];
        let pendingTxBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet).addInstructions(resolveAtaIxs);
        let pendingTxBuilderTxSize = yield pendingTxBuilder.txnSize();
        let posIndex = 0;
        let reattempt = false;
        while (posIndex < positions.length) {
            const position = positions[posIndex];
            console.log(`Handle position - ${position.getAddress().toString()}`);
            let positionTxBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.wallet);
            const { whirlpool: whirlpoolKey, positionMint } = position.getData();
            const whirlpool = whirlpools[whirlpoolKey.toBase58()];
            if (!whirlpool) {
                throw new Error(`Unable to process positionMint ${positionMint} - unable to derive whirlpool ${whirlpoolKey.toBase58()}`);
            }
            const posHandlesNativeMint = isNativeMint(whirlpool.tokenMintA) || isNativeMint(whirlpool.tokenMintB);
            const txBuilderHasNativeMint = !!affliatedTokenAtaMap[spl_token_1.NATIVE_MINT.toBase58()];
            // Add NATIVE_MINT token account creation to this transaction if position requires NATIVE_MINT handling.
            if (posHandlesNativeMint && !txBuilderHasNativeMint) {
                console.log(`needs wSOL wrapping, adding to txn`);
                prependNativeMintHandlingIx(positionTxBuilder, affliatedTokenAtaMap, destinationWallet, accountExemption);
            }
            else if (posHandlesNativeMint && txBuilderHasNativeMint) {
                console.log(`needs wSOL wrapping, but txn already has it`);
            }
            // Build position instructions
            const collectIxForPosition = constructCollectPositionIx(ctx, position, whirlpools, positionOwner, positionAuthority, affliatedTokenAtaMap);
            positionTxBuilder.addInstructions(collectIxForPosition);
            // Attempt to push the new instructions into the pending builder
            // Iterate to the next position if possible
            // Create a builder and reattempt if the current one is full.
            const incrementTxSize = yield positionTxBuilder.txnSize();
            console.log(`pendingTxBuilderTxSize - ${pendingTxBuilderTxSize} incrementTxSize - ${incrementTxSize}, propsective size - ${pendingTxBuilderTxSize + incrementTxSize}`);
            if (pendingTxBuilderTxSize + incrementTxSize < web3_js_1.PACKET_DATA_SIZE) {
                console.log(`adding to pending tx builder`);
                pendingTxBuilder.addInstruction(positionTxBuilder.compressIx(false));
                pendingTxBuilderTxSize = yield pendingTxBuilder.txnSize();
                posIndex += 1;
                reattempt = false;
            }
            else {
                if (reattempt) {
                    throw new Error(`Unable to fit collection ix for ${position.getAddress().toBase58()} in a Transaction.`);
                }
                console.log(`creating new tx builder`);
                txBuilders.push(pendingTxBuilder);
                delete affliatedTokenAtaMap[spl_token_1.NATIVE_MINT.toBase58()];
                pendingTxBuilder = new common_sdk_1.TransactionBuilder(ctx.connection, ctx.provider.wallet);
                pendingTxBuilderTxSize = 0;
                reattempt = true;
            }
            console.log(``);
        }
        txBuilders.push(pendingTxBuilder);
        return txBuilders;
    });
}
exports.collectForAllPositions = collectForAllPositions;
/**
 * Helper methods.
 */
function prependNativeMintHandlingIx(txBuilder, affliatedTokenAtaMap, destinationWallet, accountExemption) {
    let _a = (0, token_instructions_1.createWSOLAccountInstructions)(destinationWallet, common_sdk_1.ZERO, accountExemption), { address: wSOLAta } = _a, resolveWSolIx = __rest(_a, ["address"]);
    affliatedTokenAtaMap[spl_token_1.NATIVE_MINT.toBase58()] = wSOLAta;
    txBuilder.prependInstruction(resolveWSolIx);
}
const constructCollectPositionIx = (ctx, position, whirlpools, positionOwner, positionAuthority, affliatedTokenAtaMap) => {
    const ixForPosition = [];
    const { whirlpool: whirlpoolKey, liquidity, tickLowerIndex, tickUpperIndex, positionMint, rewardInfos: positionRewardInfos, } = position.getData();
    const positionKey = common_sdk_1.AddressUtil.toPubKey(position.getAddress());
    const whirlpool = whirlpools[whirlpoolKey.toBase58()];
    if (!whirlpool) {
        throw new Error(`Unable to process positionMint ${positionMint} - unable to derive whirlpool ${whirlpoolKey.toBase58()}`);
    }
    const { tickSpacing } = whirlpool;
    // Update fee and reward values if necessary
    if (!liquidity.eq(common_sdk_1.ZERO)) {
        ixForPosition.push((0, instructions_1.updateFeesAndRewardsIx)(ctx.program, {
            position: positionKey,
            whirlpool: whirlpoolKey,
            tickArrayLower: public_1.PDAUtil.getTickArray(ctx.program.programId, whirlpoolKey, public_1.TickUtil.getStartTickIndex(tickLowerIndex, tickSpacing)).publicKey,
            tickArrayUpper: public_1.PDAUtil.getTickArray(ctx.program.programId, whirlpoolKey, public_1.TickUtil.getStartTickIndex(tickUpperIndex, tickSpacing)).publicKey,
        }));
    }
    // Collect Fee
    const positionTokenAccount = (0, spl_token_utils_1.getAssociatedTokenAddressSync)(positionMint.toBase58(), positionOwner.toBase58());
    ixForPosition.push(ix_1.WhirlpoolIx.collectFeesIx(ctx.program, {
        whirlpool: whirlpoolKey,
        position: positionKey,
        positionAuthority,
        positionTokenAccount,
        tokenOwnerAccountA: affliatedTokenAtaMap[whirlpool.tokenMintA.toBase58()],
        tokenOwnerAccountB: affliatedTokenAtaMap[whirlpool.tokenMintB.toBase58()],
        tokenVaultA: whirlpool.tokenVaultA,
        tokenVaultB: whirlpool.tokenVaultB,
    }));
    // Collect Rewards
    // TODO: handle empty vault values?
    positionRewardInfos.forEach((_, index) => {
        const rewardInfo = whirlpool.rewardInfos[index];
        if (public_1.PoolUtil.isRewardInitialized(rewardInfo)) {
            ixForPosition.push(ix_1.WhirlpoolIx.collectRewardIx(ctx.program, {
                whirlpool: whirlpoolKey,
                position: positionKey,
                positionAuthority,
                positionTokenAccount,
                rewardIndex: index,
                rewardOwnerAccount: affliatedTokenAtaMap[rewardInfo.mint.toBase58()],
                rewardVault: rewardInfo.vault,
            }));
        }
    });
    return ixForPosition;
};
function resolveAtaForWhirlpools(ctx, whirlpools, destinationWallet, payer) {
    return __awaiter(this, void 0, void 0, function* () {
        const { affliatedTokenAtaMap, affliatedTokensInfoMap } = yield getAffliatedTokenAtas(ctx, whirlpools, destinationWallet);
        const tokensRequiringAtaResolve = Object.fromEntries(Object.entries(affliatedTokensInfoMap)
            .filter(([, account]) => !account)
            .map(([mint]) => [mint, affliatedTokenAtaMap[mint]]));
        const ix = [];
        Object.entries(tokensRequiringAtaResolve).forEach(([mint, ataKey]) => {
            const createAtaInstruction = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, new web3_js_1.PublicKey(mint), ataKey, destinationWallet, payer);
            ix.push({
                instructions: [createAtaInstruction],
                cleanupInstructions: [],
                signers: [],
            });
        });
        return {
            affliatedTokenAtaMap,
            resolveAtaIxs: ix,
        };
    });
}
function getAffliatedTokenAtas(ctx, whirlpoolDatas, wallet) {
    return __awaiter(this, void 0, void 0, function* () {
        const affliatedTokens = Array.from(whirlpoolDatas.reduce((accu, whirlpoolData) => {
            if (whirlpoolData) {
                const { tokenMintA, tokenMintB } = whirlpoolData;
                if (!tokenMintA.equals(spl_token_1.NATIVE_MINT)) {
                    accu.add(tokenMintA.toBase58());
                }
                if (!tokenMintB.equals(spl_token_1.NATIVE_MINT)) {
                    accu.add(tokenMintB.toBase58());
                }
                const rewardInfos = whirlpoolData.rewardInfos;
                rewardInfos.forEach((reward) => {
                    if (!reward.mint.equals(web3_js_1.PublicKey.default)) {
                        accu.add(reward.mint.toBase58());
                    }
                });
            }
            return accu;
        }, new Set()));
        const tokenMintInfoMap = convertListToMap(yield ctx.fetcher.listMintInfos(affliatedTokens, false), affliatedTokens);
        // Derive associated addresses for all affliated spl-tokens
        const affliatedTokenAtaMap = Object.fromEntries(Object.keys(tokenMintInfoMap).map((addr) => [
            addr,
            (0, spl_token_utils_1.getAssociatedTokenAddressSync)(addr, wallet.toBase58()),
        ]));
        return {
            affliatedTokenAtaMap: affliatedTokenAtaMap,
            affliatedTokensInfoMap: convertListToMap(yield ctx.fetcher.listTokenInfos(Object.values(affliatedTokenAtaMap), false), Object.keys(affliatedTokenAtaMap)),
        };
    });
}
function convertListToMap(fetchedData, addresses) {
    const result = {};
    fetchedData.forEach((data, index) => {
        if (data) {
            const addr = addresses[index];
            result[addr] = data;
        }
    });
    return result;
}
function isNativeMint(mint) {
    return mint.equals(spl_token_1.NATIVE_MINT);
}
exports.isNativeMint = isNativeMint;
